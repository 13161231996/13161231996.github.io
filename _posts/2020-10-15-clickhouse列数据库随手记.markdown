---

layout:     post
title:      "clickhouse随手记录"
subtitle:   " \"clickhouse随手记录\""
date:       2020-10-15 16:23:00
author:     "BaiDong"
header-img: "img/home-bg-art.jpg"
catalog: true
tags:
    - 列数据库
---

OLAP 场景的关键属性

    绝大多数请求是读取访问。
    数据以相当大的批次（> 1000 行）更新，而不是按单行更新；或者它根本没有更新。
    数据被添加到数据库中，但不会被修改。
    对于读取，从数据库中提取了相当多的行，但只提取了一小部分列。
    表是“宽的”，这意味着它们包含大量列。
    查询相对较少（通常每台服务器有数百个查询或每秒更少）。
    对于简单查询，允许大约 50 毫秒的延迟。
    列值相当小：数字和短字符串（例如，每个 URL 60 个字节）。
    处理单个查询时需要高吞吐量（每台服务器每秒高达数十亿行）。
    交易不是必需的。
    对数据一致性要求低。
    每个查询有一个大表。除了一张桌子，所有桌子都很小。
    查询结果明显小于源数据。换句话说，数据被过滤或聚合，因此结果适合单个服务器的 RAM

表引擎 MergeTree 使用注意事项

    MergeTree() 参数
    date-column—日期类型的列的名称。ClickHouse 会根据此列自动按月创建分区。分区名称采用"YYYYMM"格式。
    sampling_expression — 采样表达式。
    (primary, key)- 首要的关键。类型：元组（）
    index_granularity— 索引的粒度。索引“标记”之间的数据行数。值 8192 适用于大多数任务。

选择主键

    提高索引的性能。

    如果主键是(a, b)，那么c在满足以下条件的情况下，添加另一列将提高性能：
        1.有条件查询 column c。
        2.index_granularity具有相同值的长数据范围（比 长几倍）(a, b)很常见。换句话说，当添加另一列时，您可以跳过相当长的数据范围。
        3.改进数据压缩。ClickHouse 按主键对数据进行排序，因此一致性越高，压缩性越好  
增删改查注意事项
        及其不推荐高频次修改删除

MergeTree 引擎在创建时接收以下4个参数，

    日期字段的名称 （索引字段）
    采样表达式 （可选的）
    含有主键相关字段的元组
    稀疏索引的粒度（见下文）。
    以 MergeTree 作为引擎的数据表必须含有一个独立的 Date 字段。比如说， EventDate 字段。这个日期字段必须是 Date 类型的（非 DateTime 类型）。

    主键可以是任意表达式构成的元组（通常是列名称的元组），或者是单独一个字段。

    抽样表达式（可选的）可以是任意表达式。这个表达式必须在主键中。上面的例子使用了 CounterID 的哈希 intHash32 作为采样表达式，旨在近乎随机地在 CounterID 和 EventDate 内打乱数据条目。换而言之，当我们在查询中使用 SAMPLE 子句时，我们就可以得到一个近乎随机分布的用户列表。

    数据表将数据分割为小的索引块作为单位进行处理。 每个索引块之间依照主键排序。每个索引块记录了指定的开始日期和结束日期。在您插入数据时，MergeTree 就会对数据进行排序处理，以保证存储在索引块内的数据有序。 索引块之间的合并过程会在系统后台定期自动执行。MergeTree 引擎会选择几个相邻的索引块进行合并（通常是较小的索引块）， 然后对二者合并、排序。

    具体而言, 向 MergeTree 表中插入数据时，引擎会首先对新数据执行递增排序而保存索引块；其后，数据索引块之间又会进一步合并，以减少总体索引块数量。 因此，合并过程本身并无过多排序工作。

    ReplacingMergeTree

    SummingMergeTree
    AggregatingMergeTree
    CollapsingMergeTree
    VersionedCollapsingMergeTree
    GraphiteMergeTree
