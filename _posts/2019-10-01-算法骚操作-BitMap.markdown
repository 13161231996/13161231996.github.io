---

layout:     post
title:      "BitMap"
subtitle:   " \"BitMap 算法\""
date:       2019-10-01 20:03:00
author:     "BaiDong"
header-img: "img/home-bg-art.jpg"
catalog: true
tags:
    - 算法骚操作
---
1.可进行数据的快速查找，判重，删除，一般来说数据范围是int的10倍以下。
2.去重数据而达到压缩数据。


假设我们要对0-7内的5个元素(4,7,2,5,3)排序（这里假设这些元素没有重复）。那么我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），首先我们开辟1Byte的空间，将这些空间的所有Bit位都置为0。

        |0|0|0|0|0|0|0|0|
然后遍历这5个元素，首先第一个元素是4，那么就把4对应的位置为1（可以这样操作 p+(i/8)|(0×01<<(i%8)) 当然了这里的操作涉及到Big-ending和Little-ending的情况，这里默认为Big-ending。不过计算机一般是小端存储的，如intel。小端的话就是将倒数第5位置1）,因为是从零开始的，所以要把第五位置为一。

        |0|0|0|0|1|0|0|0|

然后再处理第二个元素7，将第八位置为1,，接着再处理第三个元素，一直到最后处理完所有的元素，将相应的位置为1，这时候的内存的Bit位的状态如下：

        |0|0|1|1|1|1|0|1|


然后我们现在遍历一遍Bit区域，将该位是一的位的编号输出（2，3，4，5，7），这样就达到了排序的目的。    

bitmap排序复杂度分析：
    
    Bitmap排序需要的时间复杂度和空间复杂度依赖于数据中最大的数字。

    bitmap排序的时间复杂度不是O(N)的，而是取决于待排序数组中的最大值MAX，
    在实际应用上关系也不大，比如我开10个线程去读byte数组，那么复杂度为:
    O(Max/10)。也就是要是读取的，可以用多线程的方式去读取。时间复杂度方
    面也是O(Max/n)，其中Max为byte[]数组的大小，n为线程大小。

    空间复杂度应该就是O(Max/8)bytes

BitMap算法流程

    假设需要排序或者查找的最大数MAX=10000000（lz:这里MAX应该是最大的数而不是int数据的总数！），那么我们需要申请内存空间的大小为int a[1 + MAX/32]。

    其中：a[0]在内存中占32为可以对应十进制数0-31，依次类推：
    bitmap表为：

    a[0]--------->0-31 
    a[1]--------->32-63 
    a[2]--------->64-95 
    a[3]--------->96-127 


        0 -31        32-63         64-127
          ^            ^             ^
    |     0     |      1      |      2      | 3 | 4 |

我们要把一个整数N映射到Bit-Map中去，首先要确定把这个N Mapping到哪一个数组元素中去，即确定映射元素的index。我们用int类型的数组作为map的元素，这样我们就知道了一个元素能够表示的数字个数(这里是32)。于是N/32就可以知道我们需要映射的key了。所以余下来的那个N%32就是要映射到的位数。

1.求十进制数对应在数组a中的下标:

    先由十进制数n转换为与32的余可转化为对应在数组a中的下标。

    如十进制数0-31，都应该对应在a[0]中，比如n=24,那么 n/32=0，则24对应在数组a中的下标为0。又比如n=60,那么n/32=1，则60对应在数组a中的下标为1，同理可以计算0-N在数组a中的下标。

2.求十进制数对应数组元素a[i]在0-31中的位m:

    十进制数0-31就对应0-31，而32-63则对应也是0-31，即给定一个数n可以通过模32求得对应0-31中的数。

3.利用移位0-31使得对应第m个bit位为1:

    如a[i]的第m位置1：a[i] = a[i] | (1<<m)

    如：将当前4对应的bit位置1的话，只需要1左移4位与B[0] | 即可。

BitMap算法评价:

    优点：

    1. 运算效率高，不进行比较和移位；
   
    2. 占用内存少，比如最大的数MAX=10000000；只需占用内存为     MAX/8=1250000Byte=1.25M。
   
    缺点：

    1. 所有的数据不能重复，即不可对重复的数据进行排序。（少量重复数据查找还是可以的，用2-bitmap）。

    2. 当数据类似（1，1000，10万）只有3个数据的时候，用bitmap时间复杂度和空间复杂度相当大，只有当数据比较密集时才有优势。

代码:
Python:

    class Solution:
        def strStr(self, haystack: str, needle: str) -> int:
            if len(needle) == 0:
                return 0
            next = self.next_list(needle)
            i = 0
            j = 0
            ans = -1
            n = len(haystack)
            while i < n:
                if haystack[i] == needle[j] or j == -1:
                    i += 1
                    j += 1
                else:
                    j = next[j]
                if j == len(needle):
                    ans = i - j
                    break
            return ans

        def next_list(self, needle):        
            n = len(needle)
            k = -1
            i = 0
            next = [0 for i in range(n)]
            next[0] = -1
            while i < n-1:
                if needle[i] == needle[k] or k == -1:
                    i += 1
                    k += 1
                    next[i] = k
                else:
                    k = next[k]
            return next




